<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.35">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <title>前端面试题汇总-浏览器篇-2 | Artiely'blog</title><meta name="description" content="前端面试题汇总-浏览器篇-2## Token - 服务端身份验证的流行方案### 简述：1. 需要一个secret（随机数）2. 后端利用secret和加密算法(如：HMAC-SHA256)对payload(如账号密码)生成一个字符串(token)，返回前端3. 前端每次request在header中带上token4. 后端用同样的算法解密## 身份认证服务 ...">
    <link rel="modulepreload" href="/blog-dog/assets/app.cc5d8726.js"><link rel="modulepreload" href="/blog-dog/assets/2020-8-30-frontend-brower2.html.745f8f20.js"><link rel="modulepreload" href="/blog-dog/assets/2020-8-30-frontend-brower2.html.b46f32c3.js"><link rel="prefetch" href="/blog-dog/assets/index.html.c5bbe68b.js"><link rel="prefetch" href="/blog-dog/assets/2020-8-27-frontend-css1.html.df2cb901.js"><link rel="prefetch" href="/blog-dog/assets/2020-8-28-frontend-css2.html.362fd64f.js"><link rel="prefetch" href="/blog-dog/assets/2020-8-29-frontend-js1.html.0990d5fe.js"><link rel="prefetch" href="/blog-dog/assets/2020-8-29-frontend-js2.html.37910de8.js"><link rel="prefetch" href="/blog-dog/assets/2020-8-29-frontend-js3.html.330bb2c8.js"><link rel="prefetch" href="/blog-dog/assets/2020-8-30-frontend-brower1.html.245ab6de.js"><link rel="prefetch" href="/blog-dog/assets/2020-8-31-frontend-brower3.html.3e78d545.js"><link rel="prefetch" href="/blog-dog/assets/2020-8-31-frontend-brower4.html.c8e8be2f.js"><link rel="prefetch" href="/blog-dog/assets/2021-2-23-proxy.html.db50a376.js"><link rel="prefetch" href="/blog-dog/assets/2022-1-11md-test.html.e5d83dfb.js"><link rel="prefetch" href="/blog-dog/assets/404.html.197b4016.js"><link rel="prefetch" href="/blog-dog/assets/index.html.0ea1cb86.js"><link rel="prefetch" href="/blog-dog/assets/index.html.35300fe9.js"><link rel="prefetch" href="/blog-dog/assets/index.html.67e13a3a.js"><link rel="prefetch" href="/blog-dog/assets/index.html.2930a454.js"><link rel="prefetch" href="/blog-dog/assets/index.html.6633247f.js"><link rel="prefetch" href="/blog-dog/assets/2020-8-27-frontend-css1.html.8fcf31f2.js"><link rel="prefetch" href="/blog-dog/assets/2020-8-28-frontend-css2.html.e4ecbee0.js"><link rel="prefetch" href="/blog-dog/assets/2020-8-29-frontend-js1.html.e72b844b.js"><link rel="prefetch" href="/blog-dog/assets/2020-8-29-frontend-js2.html.c58140f7.js"><link rel="prefetch" href="/blog-dog/assets/2020-8-29-frontend-js3.html.c98b0a83.js"><link rel="prefetch" href="/blog-dog/assets/2020-8-30-frontend-brower1.html.fcf1c256.js"><link rel="prefetch" href="/blog-dog/assets/2020-8-31-frontend-brower3.html.38159d99.js"><link rel="prefetch" href="/blog-dog/assets/2020-8-31-frontend-brower4.html.8b83ff26.js"><link rel="prefetch" href="/blog-dog/assets/2021-2-23-proxy.html.0c24c22b.js"><link rel="prefetch" href="/blog-dog/assets/2022-1-11md-test.html.e464c542.js"><link rel="prefetch" href="/blog-dog/assets/404.html.93146c89.js"><link rel="prefetch" href="/blog-dog/assets/index.html.97f4289c.js"><link rel="prefetch" href="/blog-dog/assets/index.html.7c8b0471.js"><link rel="prefetch" href="/blog-dog/assets/index.html.225fde64.js"><link rel="prefetch" href="/blog-dog/assets/index.html.71497e48.js"><link rel="prefetch" href="/blog-dog/assets/404.0107fcba.js"><link rel="prefetch" href="/blog-dog/assets/Timeline.a28ef1c4.js"><link rel="prefetch" href="/blog-dog/assets/Comment.d637b61c.js"><link rel="prefetch" href="/blog-dog/assets/Tags.172eb17d.js"><link rel="prefetch" href="/blog-dog/assets/vanilla-tilt.es2015.23c0b18e.js"><link rel="prefetch" href="/blog-dog/assets/lightgallery.es5.a2f185c8.js">
    <link rel="stylesheet" href="/blog-dog/assets/style.0fd4dc4d.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="dog"><!--[--><!--[--><header class="header"><div class="header-main"><div class="logo">Artiely&#39;Blog</div><form class="search-box" role="search"><input type="search" autocomplete="off" spellcheck="false" value><!----></form><nav class="nav"><!--[--><a href="/" class="link" target="_self">Home</a><a href="/timeline" class="link" target="_self">Timeline</a><a href="/comment" class="link" target="_self">Comment</a><a href="/tag" class="link" target="_self">Tags</a><a href="https://github.com/artiely" class="link" target="_blank">Github</a><!--]--></nav></div></header><div class="header-mobile"><div class="logo">Artiely&#39;Blog</div><div class="menu-btn"><i class="iconfont icon-hanbaocaidan"></i></div></div><nav class="nav-mobile" style="display:none;"><!--[--><a href="/" class="link">Home</a><a href="/timeline" class="link">Timeline</a><a href="/comment" class="link">Comment</a><a href="/tag" class="link">Tags</a><a href="https://github.com/artiely" class="link">Github</a><!--]--></nav><!--]--><!--]--><div class="body"><!--[--><!--[--><div class="sidebar-box"><div class="con"><aside class="dog-sidebar"><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading">前端面试题汇总-浏览器篇-2 <!----></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/blog-dog/posts/2020-8-30-frontend-brower2.html#token-服务端身份验证的流行方案" class="router-link-active router-link-exact-active sidebar-item" aria-label="Token - 服务端身份验证的流行方案"><!--[--><!--]--> Token - 服务端身份验证的流行方案 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/blog-dog/posts/2020-8-30-frontend-brower2.html#简述" class="router-link-active router-link-exact-active sidebar-item" aria-label="简述："><!--[--><!--]--> 简述： <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/blog-dog/posts/2020-8-30-frontend-brower2.html#身份认证" class="router-link-active router-link-exact-active sidebar-item" aria-label="身份认证"><!--[--><!--]--> 身份认证 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-dog/posts/2020-8-30-frontend-brower2.html#token机制" class="router-link-active router-link-exact-active sidebar-item" aria-label="Token机制"><!--[--><!--]--> Token机制 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/blog-dog/posts/2020-8-30-frontend-brower2.html#用户匹配" class="router-link-active router-link-exact-active sidebar-item" aria-label="用户匹配"><!--[--><!--]--> 用户匹配 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-dog/posts/2020-8-30-frontend-brower2.html#防伪造" class="router-link-active router-link-exact-active sidebar-item" aria-label="防伪造"><!--[--><!--]--> 防伪造 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-dog/posts/2020-8-30-frontend-brower2.html#防冒充" class="router-link-active router-link-exact-active sidebar-item" aria-label="防冒充"><!--[--><!--]--> 防冒充 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/blog-dog/posts/2020-8-30-frontend-brower2.html#token工作流程" class="router-link-active router-link-exact-active sidebar-item" aria-label="Token工作流程"><!--[--><!--]--> Token工作流程 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/blog-dog/posts/2020-8-30-frontend-brower2.html#生成token" class="router-link-active router-link-exact-active sidebar-item" aria-label="生成token"><!--[--><!--]--> 生成token <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-dog/posts/2020-8-30-frontend-brower2.html#拦截验证" class="router-link-active router-link-exact-active sidebar-item" aria-label="拦截验证"><!--[--><!--]--> 拦截验证 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-dog/posts/2020-8-30-frontend-brower2.html#token刷新-1" class="router-link-active router-link-exact-active sidebar-item" aria-label="token刷新"><!--[--><!--]--> token刷新 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/blog-dog/posts/2020-8-30-frontend-brower2.html#基于-token-的身份验证-json-web-token" class="router-link-active router-link-exact-active sidebar-item" aria-label="基于 Token 的身份验证：JSON Web Token"><!--[--><!--]--> 基于 Token 的身份验证：JSON Web Token <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/blog-dog/posts/2020-8-30-frontend-brower2.html#传统身份验证的方法" class="router-link-active router-link-exact-active sidebar-item" aria-label="传统身份验证的方法"><!--[--><!--]--> 传统身份验证的方法 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-dog/posts/2020-8-30-frontend-brower2.html#基于-token-的身份验证方法" class="router-link-active router-link-exact-active sidebar-item" aria-label="基于 Token 的身份验证方法"><!--[--><!--]--> 基于 Token 的身份验证方法 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-dog/posts/2020-8-30-frontend-brower2.html#jwt" class="router-link-active router-link-exact-active sidebar-item" aria-label="JWT"><!--[--><!--]--> JWT <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-dog/posts/2020-8-30-frontend-brower2.html#header" class="router-link-active router-link-exact-active sidebar-item" aria-label="Header"><!--[--><!--]--> Header <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-dog/posts/2020-8-30-frontend-brower2.html#payload" class="router-link-active router-link-exact-active sidebar-item" aria-label="Payload"><!--[--><!--]--> Payload <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-dog/posts/2020-8-30-frontend-brower2.html#signature" class="router-link-active router-link-exact-active sidebar-item" aria-label="Signature"><!--[--><!--]--> Signature <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/blog-dog/posts/2020-8-30-frontend-brower2.html#签发与验证-jwt" class="router-link-active router-link-exact-active sidebar-item" aria-label="签发与验证 JWT"><!--[--><!--]--> 签发与验证 JWT <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/blog-dog/posts/2020-8-30-frontend-brower2.html#准备项目" class="router-link-active router-link-exact-active sidebar-item" aria-label="准备项目"><!--[--><!--]--> 准备项目 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-dog/posts/2020-8-30-frontend-brower2.html#签发-jwt" class="router-link-active router-link-exact-active sidebar-item" aria-label="签发 JWT"><!--[--><!--]--> 签发 JWT <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-dog/posts/2020-8-30-frontend-brower2.html#验证-jwt" class="router-link-active router-link-exact-active sidebar-item" aria-label="验证 JWT"><!--[--><!--]--> 验证 JWT <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-dog/posts/2020-8-30-frontend-brower2.html#rs256-算法" class="router-link-active router-link-exact-active sidebar-item" aria-label="RS256 算法"><!--[--><!--]--> RS256 算法 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog-dog/posts/2020-8-30-frontend-brower2.html#签发-jwt-rs256-算法" class="router-link-active router-link-exact-active sidebar-item" aria-label="签发 JWT（RS256 算法）"><!--[--><!--]--> 签发 JWT（RS256 算法） <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><!--]--></ul><!--]--></li><!--]--></ul><!--[--><!--]--></aside></div></div><div class="md-body sino sino-kai"><div class="default-content"><!--[--><h1 id="前端面试题汇总-浏览器篇-2" tabindex="-1"><a class="header-anchor" href="#前端面试题汇总-浏览器篇-2">¶</a> <span class="prefix"></span><span class="content" id="前端面试题汇总-浏览器篇-2"><a class="header-anchor" href="#前端面试题汇总-浏览器篇-2" aria-hidden="true">#</a> 前端面试题汇总-浏览器篇-2</span><span class="suffix"></span></h1><h2 id="token-服务端身份验证的流行方案" tabindex="-1"><a class="header-anchor" href="#token-服务端身份验证的流行方案">¶</a> <span class="prefix"></span><span class="content" id="token-服务端身份验证的流行方案"><a class="header-anchor" href="#token-服务端身份验证的流行方案" aria-hidden="true">#</a> Token - 服务端身份验证的流行方案</span><span class="suffix"></span></h2><h3 id="简述" tabindex="-1"><a class="header-anchor" href="#简述">¶</a> <span class="prefix"></span><span class="content" id="简述"><a class="header-anchor" href="#简述" aria-hidden="true">#</a> 简述：</span><span class="suffix"></span></h3><ol><li>需要一个secret（随机数）</li><li>后端利用secret和加密算法(如：HMAC-SHA256)对payload(如账号密码)生成一个字符串(token)，返回前端</li><li>前端每次request在header中带上token</li><li>后端用同样的算法解密</li></ol><h2 id="身份认证" tabindex="-1"><a class="header-anchor" href="#身份认证">¶</a> <span class="prefix"></span><span class="content" id="身份认证"><a class="header-anchor" href="#身份认证" aria-hidden="true">#</a> 身份认证</span><span class="suffix"></span></h2><div class="hr-container"><span></span><div class="hr" name="分割线">分割线</div><span></span></div><p>服务端提供资源给客户端，但是某些资源是<strong>有条件</strong>的。所以服务端要能够识别请求者的身份，然后再判断所请求的资源是否可以给请求者。</p><p>token是一种身份验证的机制，初始时用户提交账号数据给服务端，服务端采用一定的策略生成一个字符串（token），token字符串中包含了少量的用户信息，并且有一定的期限。服务端会把token字符串传给客户端，客户端保存token字符串，并在接下来的请求中带上这个字符串。</p><p>它的工作流程大概是这样：</p><figure><img src="https://gitee.com/artiely/Figure-bed/raw/master/image/20200831105031.png" alt=""></figure><p>组件图</p><h2 id="token机制" tabindex="-1"><a class="header-anchor" href="#token机制">¶</a> <span class="prefix"></span><span class="content" id="token机制"><a class="header-anchor" href="#token机制" aria-hidden="true">#</a> Token机制</span><span class="suffix"></span></h2><p>在这样的流程下，我们需要考虑下面几个问题：</p><ol><li>服务端如何根据token获取用户的信息？</li><li>如何确保识别<strong>伪造</strong>的token？ 这里是指token不是经过服务端来生成的。</li><li>如何应付<strong>冒充</strong>的情况？ 非法客户端拦截了合法客户端的token，然后使用这个token向服务端发送请求，冒充合法客户端。</li></ol><h3 id="用户匹配" tabindex="-1"><a class="header-anchor" href="#用户匹配">¶</a> <span class="prefix"></span><span class="content" id="用户匹配"><a class="header-anchor" href="#用户匹配" aria-hidden="true">#</a> 用户匹配</span><span class="suffix"></span></h3><p>服务端在生成token时，加入少量的用户信息，比如用户的id。服务端接收到token之后，可以解析出这些数据，从而将token和用户关联了起来。</p><h3 id="防伪造" tabindex="-1"><a class="header-anchor" href="#防伪造">¶</a> <span class="prefix"></span><span class="content" id="防伪造"><a class="header-anchor" href="#防伪造" aria-hidden="true">#</a> 防伪造</span><span class="suffix"></span></h3><p>一般情况下，建议放入token的数据是不敏感的数据，这样只要服务端使用私钥对数据生成签名，然后和数据拼接起来，作为token的一部分即可。</p><h3 id="防冒充" tabindex="-1"><a class="header-anchor" href="#防冒充">¶</a> <span class="prefix"></span><span class="content" id="防冒充"><a class="header-anchor" href="#防冒充" aria-hidden="true">#</a> 防冒充</span><span class="suffix"></span></h3><h4 id="加干扰码" tabindex="-1"><a class="header-anchor" href="#加干扰码">¶</a> <span class="prefix"></span><span class="content" id="加干扰码"><a class="header-anchor" href="#加干扰码" aria-hidden="true">#</a> 加干扰码</span><span class="suffix"></span></h4><p>服务端在生成token时，使用了客户端的UA作为干扰码对数据加密，客户端进行请求时，会同时传入token、UA，服务端使用UA对token解密，从而验证用户的身份。</p><p>如果只是把token拷贝到另一个客户端使用，不同的UA会导致在服务端解析token失败，从而实现了一定程度的防冒充。但是攻击者如果猜到服务端使用UA作为加密钥，他可以修改自己的UA。</p><h4 id="有效期" tabindex="-1"><a class="header-anchor" href="#有效期">¶</a> <span class="prefix"></span><span class="content" id="有效期"><a class="header-anchor" href="#有效期" aria-hidden="true">#</a> 有效期</span><span class="suffix"></span></h4><p>给token加上有效期，即使被冒充也只是在一定的时间段内有效。这不是完美的防御措施，只是尽量减少损失。</p><p>服务端在生成token时，加入有效期。每次服务端接收到请求，解析token之后，判断是否已过期，如果过期就拒绝服务。</p><h4 id="token刷新" tabindex="-1"><a class="header-anchor" href="#token刷新">¶</a> <span class="prefix"></span><span class="content" id="token刷新"><a class="header-anchor" href="#token刷新" aria-hidden="true">#</a> token刷新</span><span class="suffix"></span></h4><p>如果token过期了，客户端应该对token续期或者重新生成token。这取决于token的过期机制。</p><ol><li>服务器缓存token及对应的过期时间 这个时候就可以采用续期的方式，服务器更新过期时间，token再次有效。</li><li>token中含有过期时间 这个时候需要重新生成token。</li></ol><p>在token续期或者重新生成token的时候，需要额外加入数据来验证身份。因为token已经过期了，即token已经不能用来验证用户的身份了。这个时候可以请求用户重新输入账号和密码，但是用户体验稍差。</p><p>另一种方式是使用摘要。服务端生成token，同时生成token的摘要，然后一起返回给客户端。客户端保存摘要，一般请求只需要用到token，在刷新token时，才需要用到摘要。服务端验证摘要，来验证用户的身份。因为摘要不会频繁的在客户端和服务端之间传输，所以被截取的概率较小。</p><h2 id="token工作流程" tabindex="-1"><a class="header-anchor" href="#token工作流程">¶</a> <span class="prefix"></span><span class="content" id="token工作流程"><a class="header-anchor" href="#token工作流程" aria-hidden="true">#</a> Token工作流程</span><span class="suffix"></span></h2><div class="hr-container"><span></span><div class="hr" name="分割线">分割线</div><span></span></div><h3 id="生成token" tabindex="-1"><a class="header-anchor" href="#生成token">¶</a> <span class="prefix"></span><span class="content" id="生成token"><a class="header-anchor" href="#生成token" aria-hidden="true">#</a> 生成token</span><span class="suffix"></span></h3><figure><img src="https://gitee.com/artiely/Figure-bed/raw/master/image/20200831105047.png" alt=""></figure><p>生成token</p><p>一般在登录的时候生成token。Token管理者负责根据用户的数据生成token和摘要，摘要用来给APP端刷新token用，类似于<a href="https://link.jianshu.com?t=https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=open1419317853&amp;lang=zh_CN" target="_blank" rel="noopener noreferrer">微信登录<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>中的refresh_token。</p><p>生成token的过程中，ua的充作干扰码。没有相同的ua，就无法解析生成的token字符串。如果客户端是混合开发的模式，生成token和使用token的代理可能不同（比如一个是h5，一个是原生），ua就会不同，token就无法成功的使用。可以选择其他的客户端数据作为干扰码，注意考虑下面的问题：</p><ol><li>不同的客户端，干扰码应该不同 干扰码的很大一个作用是防冒充，如果选择的充当干扰码的客户端数据没有区分性，就达不到效果。</li><li>选择充当干扰码的数据，在哪些情况下会变化？这些情况是否合理？ 比如干扰码数据中含有app的版本号，那么app版本升级就会导致干扰码变化。服务端根据新的干扰码，无法解析旧的token，此时用户必须重新登录。这种情况是合理的吗？如果不合理，干扰码中就不应该含有app的版本号。</li></ol><h3 id="拦截验证" tabindex="-1"><a class="header-anchor" href="#拦截验证">¶</a> <span class="prefix"></span><span class="content" id="拦截验证"><a class="header-anchor" href="#拦截验证" aria-hidden="true">#</a> 拦截验证</span><span class="suffix"></span></h3><figure><img src="https://gitee.com/artiely/Figure-bed/raw/master/image/20200831105120.png" alt=""></figure><p>拦截验证</p><p>客户端的每一次请求，都必须携带token、ua，拦截器会对敏感资源的访问进行拦截，然后根据ua解析token，解析不成功，表示token和ua不匹配。解析成功之后，判断token是否已过期，如果是，拒绝服务。所有都ok的情况下，拦截器放行，请求传达到业务服务者。</p><h3 id="token刷新-1" tabindex="-1"><a class="header-anchor" href="#token刷新-1">¶</a> <span class="prefix"></span><span class="content" id="token刷新-1"><a class="header-anchor" href="#token刷新-1" aria-hidden="true">#</a> token刷新</span><span class="suffix"></span></h3><figure><img src="https://gitee.com/artiely/Figure-bed/raw/master/image/20200831105137.png" alt=""></figure><p>token刷新</p><p>当token过期，用户需要刷新token。刷新token本质上是这样的：</p><blockquote class="multiquote-1"><p>服务端：这个token是你的吗？ 客户端：是的。 服务端：当初我给你token的时候，还给了一个摘要，你把摘要拿过来证明。</p></blockquote><p>客户端需要把token、摘要、ua都传给服务端，服务端对token重新生成摘要，通过判断两个摘要是否相同来验证<strong>这次请求刷新token的客户端，是不是上次请求生成token的客户端</strong>。验证通过，服务端需要使用用户数据重新生成token，用户数据则来自用ua解析token的结果。</p><h2 id="基于-token-的身份验证-json-web-token" tabindex="-1"><a class="header-anchor" href="#基于-token-的身份验证-json-web-token">¶</a> <span class="prefix"></span><span class="content" id="基于-token-的身份验证-json-web-token"><a class="header-anchor" href="#基于-token-的身份验证-json-web-token" aria-hidden="true">#</a> 基于 Token 的身份验证：JSON Web Token</span><span class="suffix"></span></h2><p>很多大型网站也都在用，比如 Facebook，Twitter，Google+，Github 等等，比起传统的身份验证方法，Token 扩展性更强，也更安全点，非常适合用在 Web 应用或者移动应用上。Token 的中文有人翻译成 “令牌”，我觉得挺好，意思就是，你拿着这个令牌，才能过一些关卡。</p><p>文章先介绍了一下传统身份验证与基于 JWT 身份验证的方法，再理解一下 JWT 的 Token 的组成部分（头部，数据，签名），最后我们会在一个 Node.js 项目上实施签发与验证 JWT 的功能。</p><h3 id="传统身份验证的方法" tabindex="-1"><a class="header-anchor" href="#传统身份验证的方法">¶</a> <span class="prefix"></span><span class="content" id="传统身份验证的方法"><a class="header-anchor" href="#传统身份验证的方法" aria-hidden="true">#</a> 传统身份验证的方法</span><span class="suffix"></span></h3><p>HTTP 是一种没有状态的协议，也就是它并不知道是谁是访问应用。这里我们把用户看成是客户端，客户端使用用户名还有密码通过了身份验证，不过下回这个客户端再发送请求时候，还得再验证一下。</p><p>解决的方法就是，当用户请求登录的时候，如果没有问题，我们在服务端生成一条记录，这个记录里可以说明一下登录的用户是谁，然后把这条记录的 ID 号发送给客户端，客户端收到以后把这个 ID 号存储在 Cookie 里，下次这个用户再向服务端发送请求的时候，可以带着这个 Cookie ，这样服务端会验证一个这个 Cookie 里的信息，看看能不能在服务端这里找到对应的记录，如果可以，说明用户已经通过了身份验证，就把用户请求的数据返回给客户端。</p><p>上面说的就是 Session，我们需要在服务端存储为登录的用户生成的 Session ，这些 Session 可能会存储在内存，磁盘，或者数据库里。我们可能需要在服务端定期的去清理过期的 Session 。</p><h3 id="基于-token-的身份验证方法" tabindex="-1"><a class="header-anchor" href="#基于-token-的身份验证方法">¶</a> <span class="prefix"></span><span class="content" id="基于-token-的身份验证方法"><a class="header-anchor" href="#基于-token-的身份验证方法" aria-hidden="true">#</a> 基于 Token 的身份验证方法</span><span class="suffix"></span></h3><p>使用基于 Token 的身份验证方法，在服务端不需要存储用户的登录记录。大概的流程是这样的：</p><ol><li>客户端使用用户名跟密码请求登录</li><li>服务端收到请求，去验证用户名与密码</li><li>验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端</li><li>客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里</li><li>客户端每次向服务端请求资源的时候需要带着服务端签发的 Token</li><li>服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据</li></ol><h3 id="jwt" tabindex="-1"><a class="header-anchor" href="#jwt">¶</a> <span class="prefix"></span><span class="content" id="jwt"><a class="header-anchor" href="#jwt" aria-hidden="true">#</a> JWT</span><span class="suffix"></span></h3><p>实施 Token 验证的方法挺多的，还有一些标准方法，比如 JWT，读作：<em>jot</em> ，表示：JSON Web Tokens 。JWT 标准的 Token 有三个部分：</p><ul><li>header（头部）</li><li>payload（数据）</li><li>signature（签名）</li></ul><p>中间用点分隔开，并且都会使用 Base64 编码，所以真正的 Token 看起来像这样：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>eyJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJuaW5naGFvLm5ldCIsImV4cCI6IjE0Mzg5NTU0NDUiLCJuYW1lIjoid2FuZ2hhbyIsImFkbWluIjp0cnVlfQ.SwyHTEx_RQppr97g4J5lKXtabJecpejuef8AqKYMAJc
</code><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1645781194500-43862">复制成功</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="eyJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJuaW5naGFvLm5ldCIsImV4cCI6IjE0Mzg5NTU0NDUiLCJuYW1lIjoid2FuZ2hhbyIsImFkbWluIjp0cnVlfQ.SwyHTEx_RQppr97g4J5lKXtabJecpejuef8AqKYMAJc
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1645781194500-43862" data-mdic-notify-delay="1000" data-mdic-copy-fail-text="复制失败" onclick="!function(t){const e={copy:(t=&#39;&#39;,e=&#39;&#39;)=&gt;new Promise((c,o)=&gt;{const n=document.createElement(&#39;textarea&#39;),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand(&#39;copy&#39;);document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display=&#39;block&#39;,setTimeout(()=&gt;{n.style.display=&#39;none&#39;},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">复制</button></div></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h3 id="header" tabindex="-1"><a class="header-anchor" href="#header">¶</a> <span class="prefix"></span><span class="content" id="header"><a class="header-anchor" href="#header" aria-hidden="true">#</a> Header</span><span class="suffix"></span></h3><p>每个 JWT token 里面都有一个 header，也就是头部数据。里面包含了使用的算法，这个 JWT 是不是带签名的或者加密的。主要就是说明一下怎么处理这个 JWT token 。</p><p>头部里包含的东西可能会根据 JWT 的类型有所变化，比如一个加密的 JWT 里面要包含使用的加密的算法。唯一在头部里面要包含的是 <em>alg</em> 这个属性，如果是加密的 JWT，这个属性的值就是使用的签名或者解密用的算法。如果是未加密的 JWT，这个属性的值要设置成 <em>none</em>。</p><p>示例：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token punctuation">{</span>
  <span class="token string-property property">&quot;alg&quot;</span><span class="token operator">:</span> <span class="token string">&quot;HS256&quot;</span>
<span class="token punctuation">}</span>
</code><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1645781194511-74099">复制成功</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="{
  &quot;alg&quot;: &quot;HS256&quot;
}
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1645781194511-74099" data-mdic-notify-delay="1000" data-mdic-copy-fail-text="复制失败" onclick="!function(t){const e={copy:(t=&#39;&#39;,e=&#39;&#39;)=&gt;new Promise((c,o)=&gt;{const n=document.createElement(&#39;textarea&#39;),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand(&#39;copy&#39;);document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display=&#39;block&#39;,setTimeout(()=&gt;{n.style.display=&#39;none&#39;},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">复制</button></div></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>意思是这个 JWT 用的算法是 HS256。上面的内容得用 <a href="https://tools.ietf.org/html/rfc4648#section-5" target="_blank" rel="noopener noreferrer">base64url<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> 的形式编码一下，所以就变成这样：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>eyJhbGciOiJIUzI1NiJ9
</code><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1645781194511-71740">复制成功</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="eyJhbGciOiJIUzI1NiJ9
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1645781194511-71740" data-mdic-notify-delay="1000" data-mdic-copy-fail-text="复制失败" onclick="!function(t){const e={copy:(t=&#39;&#39;,e=&#39;&#39;)=&gt;new Promise((c,o)=&gt;{const n=document.createElement(&#39;textarea&#39;),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand(&#39;copy&#39;);document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display=&#39;block&#39;,setTimeout(()=&gt;{n.style.display=&#39;none&#39;},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">复制</button></div></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h3 id="payload" tabindex="-1"><a class="header-anchor" href="#payload">¶</a> <span class="prefix"></span><span class="content" id="payload"><a class="header-anchor" href="#payload" aria-hidden="true">#</a> Payload</span><span class="suffix"></span></h3><p>Payload 里面是 Token 的具体内容，这些内容里面有一些是标准字段，你也可以添加其它需要的内容。下面是标准字段：</p><ul><li>iss：Issuer，发行者</li><li>sub：Subject，主题</li><li>aud：Audience，观众</li><li>exp：Expiration time，过期时间</li><li>nbf：Not before</li><li>iat：Issued at，发行时间</li><li>jti：JWT ID</li></ul><p>比如下面这个 Payload ，用到了 <em>iss</em> 发行人，还有 <em>exp</em> 过期时间这两个标准字段。另外还有两个自定义的字段，一个是 <em>name</em> ，还有一个是 <em>admin</em> 。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token punctuation">{</span>
 <span class="token string-property property">&quot;iss&quot;</span><span class="token operator">:</span> <span class="token string">&quot;ninghao.net&quot;</span><span class="token punctuation">,</span>
 <span class="token string-property property">&quot;exp&quot;</span><span class="token operator">:</span> <span class="token string">&quot;1438955445&quot;</span><span class="token punctuation">,</span>
 <span class="token string-property property">&quot;name&quot;</span><span class="token operator">:</span> <span class="token string">&quot;wanghao&quot;</span><span class="token punctuation">,</span>
 <span class="token string-property property">&quot;admin&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span>
</code><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1645781194514-314">复制成功</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="{
 &quot;iss&quot;: &quot;ninghao.net&quot;,
 &quot;exp&quot;: &quot;1438955445&quot;,
 &quot;name&quot;: &quot;wanghao&quot;,
 &quot;admin&quot;: true
}
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1645781194514-314" data-mdic-notify-delay="1000" data-mdic-copy-fail-text="复制失败" onclick="!function(t){const e={copy:(t=&#39;&#39;,e=&#39;&#39;)=&gt;new Promise((c,o)=&gt;{const n=document.createElement(&#39;textarea&#39;),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand(&#39;copy&#39;);document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display=&#39;block&#39;,setTimeout(()=&gt;{n.style.display=&#39;none&#39;},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">复制</button></div></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>使用 base64url 编码以后就变成了这个样子：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>eyJpc3MiOiJuaW5naGFvLm5ldCIsImV4cCI6IjE0Mzg5NTU0NDUiLCJuYW1lIjoid2FuZ2hhbyIsImFkbWluIjp0cnVlfQ
</code><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1645781194514-5392">复制成功</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="eyJpc3MiOiJuaW5naGFvLm5ldCIsImV4cCI6IjE0Mzg5NTU0NDUiLCJuYW1lIjoid2FuZ2hhbyIsImFkbWluIjp0cnVlfQ
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1645781194514-5392" data-mdic-notify-delay="1000" data-mdic-copy-fail-text="复制失败" onclick="!function(t){const e={copy:(t=&#39;&#39;,e=&#39;&#39;)=&gt;new Promise((c,o)=&gt;{const n=document.createElement(&#39;textarea&#39;),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand(&#39;copy&#39;);document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display=&#39;block&#39;,setTimeout(()=&gt;{n.style.display=&#39;none&#39;},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">复制</button></div></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h3 id="signature" tabindex="-1"><a class="header-anchor" href="#signature">¶</a> <span class="prefix"></span><span class="content" id="signature"><a class="header-anchor" href="#signature" aria-hidden="true">#</a> Signature</span><span class="suffix"></span></h3><p>JWT 的最后一部分是 Signature ，这部分内容有三个部分，先是用 Base64 编码的 header.payload ，再用加密算法加密一下，加密的时候要放进去一个 Secret ，这个相当于是一个密码，这个密码秘密地存储在服务端。</p><ul><li>header</li><li>payload</li><li>secret</li></ul><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> encodedString <span class="token operator">=</span> <span class="token function">base64UrlEncode</span><span class="token punctuation">(</span>header<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;.&quot;</span> <span class="token operator">+</span> <span class="token function">base64UrlEncode</span><span class="token punctuation">(</span>payload<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token constant">HMACSHA256</span><span class="token punctuation">(</span>encodedString<span class="token punctuation">,</span> <span class="token string">&#39;secret&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1645781194514-49409">复制成功</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="const encodedString = base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload); 
HMACSHA256(encodedString, &#39;secret&#39;);
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1645781194514-49409" data-mdic-notify-delay="1000" data-mdic-copy-fail-text="复制失败" onclick="!function(t){const e={copy:(t=&#39;&#39;,e=&#39;&#39;)=&gt;new Promise((c,o)=&gt;{const n=document.createElement(&#39;textarea&#39;),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand(&#39;copy&#39;);document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display=&#39;block&#39;,setTimeout(()=&gt;{n.style.display=&#39;none&#39;},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">复制</button></div></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>处理完成以后看起来像这样：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>SwyHTEx_RQppr97g4J5lKXtabJecpejuef8AqKYMAJc
</code><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1645781194514-50544">复制成功</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="SwyHTEx_RQppr97g4J5lKXtabJecpejuef8AqKYMAJc
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1645781194514-50544" data-mdic-notify-delay="1000" data-mdic-copy-fail-text="复制失败" onclick="!function(t){const e={copy:(t=&#39;&#39;,e=&#39;&#39;)=&gt;new Promise((c,o)=&gt;{const n=document.createElement(&#39;textarea&#39;),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand(&#39;copy&#39;);document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display=&#39;block&#39;,setTimeout(()=&gt;{n.style.display=&#39;none&#39;},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">复制</button></div></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>最后这个在服务端生成并且要发送给客户端的 Token 看起来像这样：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>eyJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJuaW5naGFvLm5ldCIsImV4cCI6IjE0Mzg5NTU0NDUiLCJuYW1lIjoid2FuZ2hhbyIsImFkbWluIjp0cnVlfQ.SwyHTEx_RQppr97g4J5lKXtabJecpejuef8AqKYMAJc
</code><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1645781194515-54657">复制成功</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="eyJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJuaW5naGFvLm5ldCIsImV4cCI6IjE0Mzg5NTU0NDUiLCJuYW1lIjoid2FuZ2hhbyIsImFkbWluIjp0cnVlfQ.SwyHTEx_RQppr97g4J5lKXtabJecpejuef8AqKYMAJc
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1645781194515-54657" data-mdic-notify-delay="1000" data-mdic-copy-fail-text="复制失败" onclick="!function(t){const e={copy:(t=&#39;&#39;,e=&#39;&#39;)=&gt;new Promise((c,o)=&gt;{const n=document.createElement(&#39;textarea&#39;),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand(&#39;copy&#39;);document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display=&#39;block&#39;,setTimeout(()=&gt;{n.style.display=&#39;none&#39;},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">复制</button></div></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>客户端收到这个 Token 以后把它存储下来，下回向服务端发送请求的时候就带着这个 Token 。服务端收到这个 Token ，然后进行验证，通过以后就会返回给客户端想要的资源。</p><h2 id="签发与验证-jwt" tabindex="-1"><a class="header-anchor" href="#签发与验证-jwt">¶</a> <span class="prefix"></span><span class="content" id="签发与验证-jwt"><a class="header-anchor" href="#签发与验证-jwt" aria-hidden="true">#</a> 签发与验证 JWT</span><span class="suffix"></span></h2><p>在应用里实施使用基于 JWT 这种 Token 的身份验证方法，你可以先去找一个签发与验证 JWT 的功能包。无论你的后端应用使用的是什么样的程序语言，系统，或者框架，你应该都可以找到提供类似功能的包。</p><p>下面我们在一个 Node.js 项目里，用最简单的方式来演示一下签发还有验证 JWT 的方法。</p><h3 id="准备项目" tabindex="-1"><a class="header-anchor" href="#准备项目">¶</a> <span class="prefix"></span><span class="content" id="准备项目"><a class="header-anchor" href="#准备项目" aria-hidden="true">#</a> 准备项目</span><span class="suffix"></span></h3><p>准备一个简单的 Node.js 项目：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token builtin class-name">cd</span> ~/desktop
<span class="token function">mkdir</span> jwt-demo
<span class="token builtin class-name">cd</span> jwt-demo
<span class="token function">npm</span> init -y
</code><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1645781194515-4228">复制成功</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="cd ~/desktop
mkdir jwt-demo
cd jwt-demo
npm init -y
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1645781194515-4228" data-mdic-notify-delay="1000" data-mdic-copy-fail-text="复制失败" onclick="!function(t){const e={copy:(t=&#39;&#39;,e=&#39;&#39;)=&gt;new Promise((c,o)=&gt;{const n=document.createElement(&#39;textarea&#39;),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand(&#39;copy&#39;);document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display=&#39;block&#39;,setTimeout(()=&gt;{n.style.display=&#39;none&#39;},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">复制</button></div></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>安装签发与验证 JWT 的功能包，我用的叫 <a href="https://github.com/auth0/node-jsonwebtoken" target="_blank" rel="noopener noreferrer"><em>jsonwebtoken</em><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>，在项目里安装一下这个包：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token function">npm</span> <span class="token function">install</span> jsonwebtoken --save
</code><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1645781194515-88079">复制成功</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="npm install jsonwebtoken --save
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1645781194515-88079" data-mdic-notify-delay="1000" data-mdic-copy-fail-text="复制失败" onclick="!function(t){const e={copy:(t=&#39;&#39;,e=&#39;&#39;)=&gt;new Promise((c,o)=&gt;{const n=document.createElement(&#39;textarea&#39;),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand(&#39;copy&#39;);document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display=&#39;block&#39;,setTimeout(()=&gt;{n.style.display=&#39;none&#39;},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">复制</button></div></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h3 id="签发-jwt" tabindex="-1"><a class="header-anchor" href="#签发-jwt">¶</a> <span class="prefix"></span><span class="content" id="签发-jwt"><a class="header-anchor" href="#签发-jwt" aria-hidden="true">#</a> 签发 JWT</span><span class="suffix"></span></h3><p>在项目里随便添加一个 .js 文件，比如 <em>index.js</em>，在文件里添加下面这些代码：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> jwt <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;jsonwebtoken&#39;</span><span class="token punctuation">)</span>

<span class="token comment">// Token 数据</span>
<span class="token keyword">const</span> payload <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&#39;wanghao&#39;</span><span class="token punctuation">,</span>
  <span class="token literal-property property">admin</span><span class="token operator">:</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span>

<span class="token comment">// 密钥</span>
<span class="token keyword">const</span> secret <span class="token operator">=</span> <span class="token string">&#39;ILOVENINGHAO&#39;</span>

<span class="token comment">// 签发 Token</span>
<span class="token keyword">const</span> token <span class="token operator">=</span> jwt<span class="token punctuation">.</span><span class="token function">sign</span><span class="token punctuation">(</span>payload<span class="token punctuation">,</span> secret<span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token literal-property property">expiresIn</span><span class="token operator">:</span> <span class="token string">&#39;1day&#39;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 输出签发的 Token</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span>
</code><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1645781194515-22595">复制成功</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="const jwt = require(&#39;jsonwebtoken&#39;)

// Token 数据
const payload = {
  name: &#39;wanghao&#39;,
  admin: true
}

// 密钥
const secret = &#39;ILOVENINGHAO&#39;

// 签发 Token
const token = jwt.sign(payload, secret, { expiresIn: &#39;1day&#39; })

// 输出签发的 Token
console.log(token)
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1645781194515-22595" data-mdic-notify-delay="1000" data-mdic-copy-fail-text="复制失败" onclick="!function(t){const e={copy:(t=&#39;&#39;,e=&#39;&#39;)=&gt;new Promise((c,o)=&gt;{const n=document.createElement(&#39;textarea&#39;),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand(&#39;copy&#39;);document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display=&#39;block&#39;,setTimeout(()=&gt;{n.style.display=&#39;none&#39;},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">复制</button></div></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>非常简单，就是用了刚刚为项目安装的 jsonwebtoken 里面提供的 jwt.sign 功能，去签发一个 token。这个 sign 方法需要三个参数：</p><ol><li><em>playload</em>：签发的 token 里面要包含的一些数据。</li><li><em>secret</em>：签发 token 用的密钥，在验证 token 的时候同样需要用到这个密钥。</li><li><em>options</em>：一些其它的选项。</li></ol><p>在命令行下面，用 <em>node</em> 命令，执行一下项目里的 <em>index.js</em> 这个文件（<em>node index.js</em>），会输出应用签发的 <em>token</em>：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoid2FuZ2hhbyIsImFkbWluIjp0cnVlLCJpYXQiOjE1MjkwMzM5MDYsImV4cCI6MTUyOTEyMDMwNn0.DctA2QlUCrM6wLWkIO78wBVN0NLpjoIq4T5B_2WJ-PU
</code><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1645781194516-89421">复制成功</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoid2FuZ2hhbyIsImFkbWluIjp0cnVlLCJpYXQiOjE1MjkwMzM5MDYsImV4cCI6MTUyOTEyMDMwNn0.DctA2QlUCrM6wLWkIO78wBVN0NLpjoIq4T5B_2WJ-PU
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1645781194516-89421" data-mdic-notify-delay="1000" data-mdic-copy-fail-text="复制失败" onclick="!function(t){const e={copy:(t=&#39;&#39;,e=&#39;&#39;)=&gt;new Promise((c,o)=&gt;{const n=document.createElement(&#39;textarea&#39;),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand(&#39;copy&#39;);document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display=&#39;block&#39;,setTimeout(()=&gt;{n.style.display=&#39;none&#39;},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">复制</button></div></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>上面的 Token 内容并没有加密，所以如果用一些 JWT 解码功能，可以看到 Token 里面包含的内容，内容由三个部分组成，像这样：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// header</span>
<span class="token punctuation">{</span>
  <span class="token string-property property">&quot;alg&quot;</span><span class="token operator">:</span> <span class="token string">&quot;HS256&quot;</span><span class="token punctuation">,</span> 
  <span class="token string-property property">&quot;typ&quot;</span><span class="token operator">:</span> <span class="token string">&quot;JWT&quot;</span>
<span class="token punctuation">}</span>

<span class="token comment">// payload</span>
<span class="token punctuation">{</span>
  <span class="token string-property property">&quot;admin&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> 
  <span class="token string-property property">&quot;iat&quot;</span><span class="token operator">:</span> <span class="token number">1529033906</span><span class="token punctuation">,</span> 
  <span class="token string-property property">&quot;name&quot;</span><span class="token operator">:</span> <span class="token string">&quot;wanghao&quot;</span><span class="token punctuation">,</span> 
  <span class="token string-property property">&quot;exp&quot;</span><span class="token operator">:</span> <span class="token number">1529120306</span>
<span class="token punctuation">}</span>

<span class="token comment">// signature</span>
DctA2QlUCrM6wLWkIO78wBVN0NLpjoIq4T5B_2WJ<span class="token operator">-</span><span class="token constant">PU</span>
</code><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1645781194516-40255">复制成功</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="// header
{
  &quot;alg&quot;: &quot;HS256&quot;, 
  &quot;typ&quot;: &quot;JWT&quot;
}

// payload
{
  &quot;admin&quot;: true, 
  &quot;iat&quot;: 1529033906, 
  &quot;name&quot;: &quot;wanghao&quot;, 
  &quot;exp&quot;: 1529120306
}

// signature
DctA2QlUCrM6wLWkIO78wBVN0NLpjoIq4T5B_2WJ-PU
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1645781194516-40255" data-mdic-notify-delay="1000" data-mdic-copy-fail-text="复制失败" onclick="!function(t){const e={copy:(t=&#39;&#39;,e=&#39;&#39;)=&gt;new Promise((c,o)=&gt;{const n=document.createElement(&#39;textarea&#39;),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand(&#39;copy&#39;);document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display=&#39;block&#39;,setTimeout(()=&gt;{n.style.display=&#39;none&#39;},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">复制</button></div></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>假设用户通过了某种身份验证，你就可以使用上面的签发 Token 的功能为用户签发一个 Token。一般在客户端那里会把它保存在 Cookie 或 LocalStorage 里面。</p><p>用户下次向我们的应用请求受保护的资源的时候，可以在请求里带着我们给它签发的这个 Token，后端应用收到请求，检查签名，如果验证通过确定这个 Token 是我们自己签发的，那就可以为用户响应回他需要的资源。</p><h3 id="验证-jwt" tabindex="-1"><a class="header-anchor" href="#验证-jwt">¶</a> <span class="prefix"></span><span class="content" id="验证-jwt"><a class="header-anchor" href="#验证-jwt" aria-hidden="true">#</a> 验证 JWT</span><span class="suffix"></span></h3><p>验证 JWT 的用效性，确定一下用户的 JWT 是我们自己签发的，首先要得到用户的这个 JWT Token，然后用 <em>jwt.verify</em> 这个方法去做一下验证。这个方法是 Node.js 的 jsonwebtoken 这个包里提供的，在其它的应用框架或者系统里，你可能会找到类似的方法来验证 JWT。</p><p>打开项目的 index.js 文件，里面添加几行代码：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 验证 Token</span>
jwt<span class="token punctuation">.</span><span class="token function">verify</span><span class="token punctuation">(</span>token<span class="token punctuation">,</span> <span class="token string">&#39;bad secret&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">error<span class="token punctuation">,</span> decoded</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>error<span class="token punctuation">.</span>message<span class="token punctuation">)</span>
    <span class="token keyword">return</span>
  <span class="token punctuation">}</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>decoded<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1645781194516-20521">复制成功</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="// 验证 Token
jwt.verify(token, &#39;bad secret&#39;, (error, decoded) =&gt; {
  if (error) {
    console.log(error.message)
    return
  }
  console.log(decoded)
})
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1645781194516-20521" data-mdic-notify-delay="1000" data-mdic-copy-fail-text="复制失败" onclick="!function(t){const e={copy:(t=&#39;&#39;,e=&#39;&#39;)=&gt;new Promise((c,o)=&gt;{const n=document.createElement(&#39;textarea&#39;),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand(&#39;copy&#39;);document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display=&#39;block&#39;,setTimeout(()=&gt;{n.style.display=&#39;none&#39;},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">复制</button></div></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>把要验证的 Token 数据，还有签发这个 Token 的时候用的那个密钥告诉 <em>verify</em> 这个方法，在一个回调里面有两个参数，<em>error</em> 表示错误，<em>decoded</em> 是解码之后的 Token 数据。</p><p>执行：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token function">node</span> ~/desktop/jwt-demo/index.js
</code><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1645781194518-46522">复制成功</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="node ~/desktop/jwt-demo/index.js
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1645781194518-46522" data-mdic-notify-delay="1000" data-mdic-copy-fail-text="复制失败" onclick="!function(t){const e={copy:(t=&#39;&#39;,e=&#39;&#39;)=&gt;new Promise((c,o)=&gt;{const n=document.createElement(&#39;textarea&#39;),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand(&#39;copy&#39;);document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display=&#39;block&#39;,setTimeout(()=&gt;{n.style.display=&#39;none&#39;},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">复制</button></div></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>输出：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoid2FuZ2hhbyIsImFkbWluIjp0cnVlLCJpYXQiOjE1MjkwMzQ3MzMsImV4cCI6MTUyOTEyMTEzM30.swXojmu7VimFu3BoIgAxxpmm2J05dvD0HT3yu10vuqU

invalid signature
</code><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1645781194518-67270">复制成功</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoid2FuZ2hhbyIsImFkbWluIjp0cnVlLCJpYXQiOjE1MjkwMzQ3MzMsImV4cCI6MTUyOTEyMTEzM30.swXojmu7VimFu3BoIgAxxpmm2J05dvD0HT3yu10vuqU

invalid signature
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1645781194518-67270" data-mdic-notify-delay="1000" data-mdic-copy-fail-text="复制失败" onclick="!function(t){const e={copy:(t=&#39;&#39;,e=&#39;&#39;)=&gt;new Promise((c,o)=&gt;{const n=document.createElement(&#39;textarea&#39;),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand(&#39;copy&#39;);document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display=&#39;block&#39;,setTimeout(()=&gt;{n.style.display=&#39;none&#39;},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">复制</button></div></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>注意输出了一个 invalid signature ，表示 Token 里的签名不对，这是因为我们组长 <em>verify</em> 方法提供的密钥并不是签发 Token 的时候用的那个密钥。这样修改一下：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>jwt.verify<span class="token punctuation">(</span>token, secret, <span class="token punctuation">(</span>error, decoded<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span> <span class="token punctuation">..</span>.
</code><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1645781194518-7388">复制成功</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="jwt.verify(token, secret, (error, decoded) =&gt; { ...
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1645781194518-7388" data-mdic-notify-delay="1000" data-mdic-copy-fail-text="复制失败" onclick="!function(t){const e={copy:(t=&#39;&#39;,e=&#39;&#39;)=&gt;new Promise((c,o)=&gt;{const n=document.createElement(&#39;textarea&#39;),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand(&#39;copy&#39;);document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display=&#39;block&#39;,setTimeout(()=&gt;{n.style.display=&#39;none&#39;},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">复制</button></div></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>再次运行，会输出类似的数据：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoid2FuZ2hhbyIsImFkbWluIjp0cnVlLCJpYXQiOjE1MjkwMzUzODYsImV4cCI6MTUyOTEyMTc4Nn0.mkNrt4TfcfmP22xd3C_GQn8qnUmlB39dKT9SpIBTBGI

<span class="token punctuation">{</span> name: <span class="token string">&#39;wanghao&#39;</span>, admin: true, iat: <span class="token number">1529035386</span>, exp: <span class="token number">1529121786</span> <span class="token punctuation">}</span>
</code><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1645781194518-68114">复制成功</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoid2FuZ2hhbyIsImFkbWluIjp0cnVlLCJpYXQiOjE1MjkwMzUzODYsImV4cCI6MTUyOTEyMTc4Nn0.mkNrt4TfcfmP22xd3C_GQn8qnUmlB39dKT9SpIBTBGI

{ name: &#39;wanghao&#39;, admin: true, iat: 1529035386, exp: 1529121786 }
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1645781194518-68114" data-mdic-notify-delay="1000" data-mdic-copy-fail-text="复制失败" onclick="!function(t){const e={copy:(t=&#39;&#39;,e=&#39;&#39;)=&gt;new Promise((c,o)=&gt;{const n=document.createElement(&#39;textarea&#39;),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand(&#39;copy&#39;);document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display=&#39;block&#39;,setTimeout(()=&gt;{n.style.display=&#39;none&#39;},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">复制</button></div></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="rs256-算法" tabindex="-1"><a class="header-anchor" href="#rs256-算法">¶</a> <span class="prefix"></span><span class="content" id="rs256-算法"><a class="header-anchor" href="#rs256-算法" aria-hidden="true">#</a> RS256 算法</span><span class="suffix"></span></h3><p>默认签发还有验证 Token 的时候用的是 HS256 算法，这种算法需要一个密钥（密码）。我们还可以使用 RS256 算法签发与验证 JWT。这种方法可以让我们分离开签发与验证，签发时需要用一个密钥，验证时使用公钥，也就是有公钥的地方只能做验证，但不能签发 JWT。</p><p>在项目下面创建一个新的目录，里面可以存储即将生成的密钥与公钥文件。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token builtin class-name">cd</span> ~/desktop/jwt-demo
<span class="token function">mkdir</span> config
<span class="token builtin class-name">cd</span> config
</code><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1645781194518-42575">复制成功</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="cd ~/desktop/jwt-demo
mkdir config
cd config
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1645781194518-42575" data-mdic-notify-delay="1000" data-mdic-copy-fail-text="复制失败" onclick="!function(t){const e={copy:(t=&#39;&#39;,e=&#39;&#39;)=&gt;new Promise((c,o)=&gt;{const n=document.createElement(&#39;textarea&#39;),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand(&#39;copy&#39;);document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display=&#39;block&#39;,setTimeout(()=&gt;{n.style.display=&#39;none&#39;},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">复制</button></div></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h4 id="密钥" tabindex="-1"><a class="header-anchor" href="#密钥">¶</a> <span class="prefix"></span><span class="content" id="密钥"><a class="header-anchor" href="#密钥" aria-hidden="true">#</a> 密钥</span><span class="suffix"></span></h4><p>先生成一个密钥文件：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>ssh-keygen -t rsa -b <span class="token number">2048</span> -f private.key
</code><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1645781194519-91360">复制成功</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="ssh-keygen -t rsa -b 2048 -f private.key
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1645781194519-91360" data-mdic-notify-delay="1000" data-mdic-copy-fail-text="复制失败" onclick="!function(t){const e={copy:(t=&#39;&#39;,e=&#39;&#39;)=&gt;new Promise((c,o)=&gt;{const n=document.createElement(&#39;textarea&#39;),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand(&#39;copy&#39;);document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display=&#39;block&#39;,setTimeout(()=&gt;{n.style.display=&#39;none&#39;},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">复制</button></div></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h4 id="公钥" tabindex="-1"><a class="header-anchor" href="#公钥">¶</a> <span class="prefix"></span><span class="content" id="公钥"><a class="header-anchor" href="#公钥" aria-hidden="true">#</a> 公钥</span><span class="suffix"></span></h4><p>基于上面生成的密钥，再去创建一个对应的公钥：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>openssl rsa -in private.key -pubout -outform PEM -out public.key
</code><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1645781194519-96835">复制成功</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="openssl rsa -in private.key -pubout -outform PEM -out public.key
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1645781194519-96835" data-mdic-notify-delay="1000" data-mdic-copy-fail-text="复制失败" onclick="!function(t){const e={copy:(t=&#39;&#39;,e=&#39;&#39;)=&gt;new Promise((c,o)=&gt;{const n=document.createElement(&#39;textarea&#39;),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand(&#39;copy&#39;);document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display=&#39;block&#39;,setTimeout(()=&gt;{n.style.display=&#39;none&#39;},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">复制</button></div></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h3 id="签发-jwt-rs256-算法" tabindex="-1"><a class="header-anchor" href="#签发-jwt-rs256-算法">¶</a> <span class="prefix"></span><span class="content" id="签发-jwt-rs256-算法"><a class="header-anchor" href="#签发-jwt-rs256-算法" aria-hidden="true">#</a> 签发 JWT（RS256 算法）</span><span class="suffix"></span></h3><p>用 RS256 算法签发 JWT 的时候，需要从文件系统上读取创建的密钥文件里的内容。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;fs&#39;</span><span class="token punctuation">)</span>

<span class="token comment">// 获取签发 JWT 时需要用的密钥</span>
<span class="token keyword">const</span> privateKey <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span><span class="token string">&#39;./config/private.key&#39;</span><span class="token punctuation">)</span>
</code><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1645781194519-74435">复制成功</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="const fs = require(&#39;fs&#39;)

// 获取签发 JWT 时需要用的密钥
const privateKey = fs.readFileSync(&#39;./config/private.key&#39;)
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1645781194519-74435" data-mdic-notify-delay="1000" data-mdic-copy-fail-text="复制失败" onclick="!function(t){const e={copy:(t=&#39;&#39;,e=&#39;&#39;)=&gt;new Promise((c,o)=&gt;{const n=document.createElement(&#39;textarea&#39;),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand(&#39;copy&#39;);document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display=&#39;block&#39;,setTimeout(()=&gt;{n.style.display=&#39;none&#39;},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">复制</button></div></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>签发仍然使用 jwt.sign 方法，只不过在选项参数里特别说明一下使用的算法是 RS256：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 签发 Token</span>
<span class="token keyword">const</span> tokenRS256 <span class="token operator">=</span> jwt<span class="token punctuation">.</span><span class="token function">sign</span><span class="token punctuation">(</span>payload<span class="token punctuation">,</span> privateKey<span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token literal-property property">algorithm</span><span class="token operator">:</span> <span class="token string">&#39;RS256&#39;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 输出签发的 Token</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;RS256 算法：&#39;</span><span class="token punctuation">,</span> tokenRS256<span class="token punctuation">)</span>
</code><div class="m-mdic-copy-wrapper"><div class="u-mdic-copy-notify" id="j-notify-1645781194519-11356">复制成功</div><button class="u-mdic-copy-btn j-mdic-copy-btn" data-mdic-content="// 签发 Token
const tokenRS256 = jwt.sign(payload, privateKey, { algorithm: &#39;RS256&#39; })

// 输出签发的 Token
console.log(&#39;RS256 算法：&#39;, tokenRS256)
" data-mdic-attach-content="" data-mdic-notify-id="j-notify-1645781194519-11356" data-mdic-notify-delay="1000" data-mdic-copy-fail-text="复制失败" onclick="!function(t){const e={copy:(t=&#39;&#39;,e=&#39;&#39;)=&gt;new Promise((c,o)=&gt;{const n=document.createElement(&#39;textarea&#39;),d=e?`\n\n${e}`:e;n.value=`${t}${d}`,document.body.appendChild(n),n.select();try{const t=document.execCommand(&#39;copy&#39;);document.body.removeChild(n),t?c():o()}catch(t){document.body.removeChild(n),o()}}),btnClick(t){const c=t&amp;&amp;t.dataset?t.dataset:{},o=c.mdicNotifyId,n=document.getElementById(o),d=c.mdicNotifyDelay,i=c.mdicCopyFailText;e.copy(c.mdicContent,c.mdicAttachContent).then(()=&gt;{n.style.display=&#39;block&#39;,setTimeout(()=&gt;{n.style.display=&#39;none&#39;},d)}).catch(()=&gt;{alert(i)})}};e.btnClick(t)}(this);">复制</button></div></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><!--]--></div></div><!----><div class="bottom reading-progress" data-v-e132c114><div style="" class="progress" data-v-e132c114></div></div><!--]--><!--]--></div><!--[--><footer class="footer"> powered by <a target="_blank" href="https://github.com/artiely"> Artiely</a></footer><!--]--><div class="theme-box"><div class="theme-btn-box"><span class="active theme-btn">晓露</span><span class="theme-btn">寝安</span><span class="theme-btn">浅云</span><span class="theme-btn">逍遥</span><span class="theme-btn">十漾</span><span class="theme-btn">轻拟</span></div><div class="trigger"><i class="iconfont icon-pifu"></i></div></div></div><!----><!--]--></div>
    <script type="module" src="/blog-dog/assets/app.cc5d8726.js" defer></script>
  </body>
</html>
